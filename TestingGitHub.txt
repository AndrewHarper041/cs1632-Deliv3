Testing GitHub.com
Andrew Harper adh41
Austin Choi auc5
CS 1632 - Deliverable 3: Web Testing with BDD
Summary:
        GitHub was selected due to it being feature rich (clearly too much to easily do this style of testing), well known, and familiar. Also we did not expect testing to involve many issues with javascript or dynamic content at first. In selecting what aspects to tests, I tried to select mostly ‘core’ features, namely account creation issues and control over repositories. 
        User Story 1 was testing the ability for a new user to create an account, and the scenarios given make to cover a large number of potential issues a user will have. For example, we test that on incorrect input of username or password an account can’t be created, specifically looking at site prompts at what is wrong and how. The tests are thus meant to focus on the user's view of the feature, in line with BDD. 
        US2 and US3 refer directly to handling a registered user’s repos, as that could be considered the core feature of GitHub. Between the two, ability to set and alter various settings is tested. Scenarios cover situations from what you decide on creation (US2) to changing ownership or deleting a repo (US3).
        
 Issues:
        An issue with the testing the site came from pure scope. There are many features that probably should be testing, and it would take much time to test them all properly. Another issue with designing the test specifically, is knowing how far the testing should go and what should be used to verify success. For example, on creating a new user we can assert against what the site should display on success, but we can not be sure that the user was actually created correctly and rather just know that the page was displaying what it should if a user creation was successful. That seems to just be an inevitable fact of doing black box testing however.
        Many of the success verifications that we asserted against were spawned by a javascript onchange event. This initially caused many tests to fail as the selenium sendKeys method does not invoke the event. This turned out to be easily ‘fixed’ with a hack that uses jquery to force an onchange event on the object in question. Applying this hack made testing against javascript prompts possible.
        Biggest issue, and even with looking into it no satisfying answer was found, was how to handle authentication. The answer most pleasing was to simply have cookies set for the browser so that automatic user authentication occurs. Doing this introduces another issue in that when features for unregistered users or not logged in users are also tested. One hackish solution would be to start logged in, ending with logging out and then do any unregistered user testing. This requires order of test to matter, and the order that the tests were ran at was different between us. Refactoring our tests so that they ran independent of order was probably the biggest obstacle, as when done in selenium, they can run in order and were designed as such initially. This was done by making and deleting temporary users/repos all in one test, so any changes will be removed when the test is done. Before all were properly done this way, a problem occurred were tests that had errors would fail to delete temporary test objects, and cause other later tests, that would work on their own, to fail due to attempts to create a repo that already exists, or other things.
        Finally, all the order dependent and failing messing things up caused a more meta issue. We both got very different testing results when running the same test suite. We are not even entirely sure why in some instances, though it mostly seems to be an issue with our eclipse setups running tests in a different order. This made it difficult to tell where problems actually are, especially due to certain tests passing when ran on there own despite failing in suite.